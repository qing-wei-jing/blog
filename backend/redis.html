<!doctype html>
<html lang="zn-ch">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.25" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>redis | 魔法少女小凯的后端知识库</title><meta name="description" content="要记得好好吃饭喵!">
    <link rel="preload" href="/blog/assets/style-DZNVK-lj.css" as="style"><link rel="stylesheet" href="/blog/assets/style-DZNVK-lj.css">
    <link rel="modulepreload" href="/blog/assets/app-l44R1w7S.js"><link rel="modulepreload" href="/blog/assets/redis.html-DxqT1NTm.js">
    <link rel="prefetch" href="/blog/assets/index.html-fvHFoV4c.js" as="script"><link rel="prefetch" href="/blog/assets/get-started.html-DxUgfzVk.js" as="script"><link rel="prefetch" href="/blog/assets/java.html-Doi25sb8.js" as="script"><link rel="prefetch" href="/blog/assets/kafka.html-XcIQbVFx.js" as="script"><link rel="prefetch" href="/blog/assets/microservices-components.html-CGoQcA4T.js" as="script"><link rel="prefetch" href="/blog/assets/mysql.html-CVkmXpgx.js" as="script"><link rel="prefetch" href="/blog/assets/spring.html-DRk0AZhJ.js" as="script"><link rel="prefetch" href="/blog/assets/vue2.html-DtU_29jc.js" as="script"><link rel="prefetch" href="/blog/assets/vue3.html-5HKj3FAp.js" as="script"><link rel="prefetch" href="/blog/assets/good-code.html-DTvZNMpP.js" as="script"><link rel="prefetch" href="/blog/assets/minHabit.html-BCP_vFSD.js" as="script"><link rel="prefetch" href="/blog/assets/numberConvertError.html-Dw5IbiLN.js" as="script"><link rel="prefetch" href="/blog/assets/yinShi.html-Ce4_GhdB.js" as="script"><link rel="prefetch" href="/blog/assets/ry-vue.html-FFBUUYwK.js" as="script"><link rel="prefetch" href="/blog/assets/docker.html-DPdkiwFS.js" as="script"><link rel="prefetch" href="/blog/assets/nginx.html-CdtMCMQq.js" as="script"><link rel="prefetch" href="/blog/assets/markdown.html-D8SnhI-h.js" as="script"><link rel="prefetch" href="/blog/assets/404.html-DXlEv5j5.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/blog/"><img class="vp-site-logo" src="https://vuejs.press/images/hero.png" alt="魔法少女小凯的后端知识库"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">魔法少女小凯的后端知识库</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="前端相关"><span class="title">前端相关</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="前端相关"><span class="title">前端相关</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>vue集合</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/frontend/vue3.html" aria-label="Vue3教程"><!--[--><!--[--><!--]--><!--]-->Vue3教程<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/frontend/vue2.html" aria-label="vue2教程"><!--[--><!--[--><!--]--><!--]-->vue2教程<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="后端相关"><span class="title">后端相关</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="后端相关"><span class="title">后端相关</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/java.html" aria-label="Java"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/spring.html" aria-label="Spring 中 Bean 的几种注入方式详解"><!--[--><!--[--><!--]--><!--]-->Spring 中 Bean 的几种注入方式详解<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/mysql.html" aria-label="Mysql"><!--[--><!--[--><!--]--><!--]-->Mysql<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/microservices-components.html" aria-label="微服务常用组件"><!--[--><!--[--><!--]--><!--]-->微服务常用组件<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/kafka.html" aria-label="kafka"><!--[--><!--[--><!--]--><!--]-->kafka<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="开源项目学习"><span class="title">开源项目学习</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="开源项目学习"><span class="title">开源项目学习</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>若伊全家桶</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/openSource/ry-vue.html" aria-label="若伊基础版 (vue2 / vue3)"><!--[--><!--[--><!--]--><!--]-->若伊基础版 (vue2 / vue3)<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="运维相关"><span class="title">运维相关</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="运维相关"><span class="title">运维相关</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/server/nginx.html" aria-label="nginx"><!--[--><!--[--><!--]--><!--]-->nginx<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/server/docker.html" aria-label="docker"><!--[--><!--[--><!--]--><!--]-->docker<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="工具使用"><span class="title">工具使用</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="工具使用"><span class="title">工具使用</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/tool/markdown.html" aria-label="Markdown 速查表"><!--[--><!--[--><!--]--><!--]-->Markdown 速查表<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="其余杂谈"><span class="title">其余杂谈</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="其余杂谈"><span class="title">其余杂谈</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/dailyTalk/good-code.html" aria-label="关于优质代码的思考"><!--[--><!--[--><!--]--><!--]-->关于优质代码的思考<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>好文感悟</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/dailyTalk/minHabit.html" aria-label="微习惯"><!--[--><!--[--><!--]--><!--]-->微习惯<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="前端相关"><span class="title">前端相关</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="前端相关"><span class="title">前端相关</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>vue集合</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/frontend/vue3.html" aria-label="Vue3教程"><!--[--><!--[--><!--]--><!--]-->Vue3教程<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/frontend/vue2.html" aria-label="vue2教程"><!--[--><!--[--><!--]--><!--]-->vue2教程<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="后端相关"><span class="title">后端相关</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="后端相关"><span class="title">后端相关</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/java.html" aria-label="Java"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/spring.html" aria-label="Spring 中 Bean 的几种注入方式详解"><!--[--><!--[--><!--]--><!--]-->Spring 中 Bean 的几种注入方式详解<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/mysql.html" aria-label="Mysql"><!--[--><!--[--><!--]--><!--]-->Mysql<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/microservices-components.html" aria-label="微服务常用组件"><!--[--><!--[--><!--]--><!--]-->微服务常用组件<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/backend/kafka.html" aria-label="kafka"><!--[--><!--[--><!--]--><!--]-->kafka<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="开源项目学习"><span class="title">开源项目学习</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="开源项目学习"><span class="title">开源项目学习</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>若伊全家桶</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/openSource/ry-vue.html" aria-label="若伊基础版 (vue2 / vue3)"><!--[--><!--[--><!--]--><!--]-->若伊基础版 (vue2 / vue3)<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="运维相关"><span class="title">运维相关</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="运维相关"><span class="title">运维相关</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/server/nginx.html" aria-label="nginx"><!--[--><!--[--><!--]--><!--]-->nginx<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/server/docker.html" aria-label="docker"><!--[--><!--[--><!--]--><!--]-->docker<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="工具使用"><span class="title">工具使用</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="工具使用"><span class="title">工具使用</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/tool/markdown.html" aria-label="Markdown 速查表"><!--[--><!--[--><!--]--><!--]-->Markdown 速查表<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="其余杂谈"><span class="title">其余杂谈</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="其余杂谈"><span class="title">其余杂谈</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/dailyTalk/good-code.html" aria-label="关于优质代码的思考"><!--[--><!--[--><!--]--><!--]-->关于优质代码的思考<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>好文感悟</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/dailyTalk/minHabit.html" aria-label="微习惯"><!--[--><!--[--><!--]--><!--]-->微习惯<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">redis <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div id="content"><h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>redis</span></a></h1><h2 id="redis的3种特殊数据结构介绍" tabindex="-1"><a class="header-anchor" href="#redis的3种特殊数据结构介绍"><span>redis的3种特殊数据结构介绍</span></a></h2><h3 id="_1-geospecial" tabindex="-1"><a class="header-anchor" href="#_1-geospecial"><span>1.Geospecial</span></a></h3><h4 id="_1-介绍-是什么" tabindex="-1"><a class="header-anchor" href="#_1-介绍-是什么"><span>1.介绍，是什么</span></a></h4><p>Redis的Geospatial（地理空间）功能是一组专门用于处理地理位置数据的命令，基于Redis的有序集合(Sorted Set)数据结构实现。 它允许你存储地理坐标（经度和纬度），并执行各种基于位置的计算和查询。</p><div class="language-redis line-numbers-mode" data-highlighter="prismjs" data-ext="redis"><pre><code class="language-redis"><span class="line"># GEOADD：添加一个或多个地理空间位置到指定的key中</span>
<span class="line">GEOADD cities 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;</span>
<span class="line"># GEOPOS：获取一个或多个位置的地理坐标</span>
<span class="line">GEOPOS cities &quot;Palermo&quot; &quot;Catania&quot;</span>
<span class="line"># GEODIST：计算两个位置之间的距离</span>
<span class="line">GEODIST cities &quot;Palermo&quot; &quot;Catania&quot; km</span>
<span class="line"># GEORADIUS：以给定的经纬度为中心，查找指定半径内的位置</span>
<span class="line">GEORADIUS cities 15 37 100 km</span>
<span class="line"># GEORADIUSBYMEMBER：以给定的成员为中心，查找指定半径内的位置</span>
<span class="line">GEORADIUSBYMEMBER cities &quot;Palermo&quot; 200 km</span>
<span class="line"># GEOHASH：获取一个或多个位置的Geohash值</span>
<span class="line">GEOHASH cities &quot;Palermo&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-应用场景" tabindex="-1"><a class="header-anchor" href="#_2-应用场景"><span>2.应用场景</span></a></h4><ol><li>附近的人/地点搜索：</li></ol><ul><li>查找用户周围5公里内的餐厅</li><li>显示附近的加油站或ATM机</li><li>社交应用中查找附近的朋友</li></ul><ol start="2"><li>配送和物流</li></ol><ul><li>查找用户周围5公里内的餐厅</li><li>显示附近的加油站或ATM机</li></ul><h4 id="_3-底层的数据结构" tabindex="-1"><a class="header-anchor" href="#_3-底层的数据结构"><span>3.底层的数据结构</span></a></h4><p>Geospecial的底层数据结构是Zset(有序集合)</p><p>所有 GEO 命令实际上都是操作一个特殊的 Sorted Set：<br> Key 对应 Sorted Set 的名称<br> Member 是地点名称（如&quot;北京&quot;、&quot;上海&quot;）<br> Score 是经过 Geohash 编码后的 52 位整数值</p><p>Redis 使用 Geohash 将二维的经纬度转换为一维的分数(score)：<br> 经纬度标准化：<br> 经度范围 [-180,180] → 映射到 [0,2^32]<br> 纬度范围 [-90,90] → 映射到 [0,2^32]</p><p>交替编码：<br> 将经度和纬度的二进制位交替排列<br> 例如：经度比特1 → 纬度比特1 → 经度比特2 → 纬度比特2 → ...</p><p>生成52位整数：<br> Redis 使用 52 位整数表示（对应 double 类型的精度）<br> 26位来自经度，26位来自纬度</p><p>例如存储坐标（经度13.361389，纬度38.115556）：<br> 1.标准化坐标<br> 2.转换为二进制表示<br> 3.交替组合经度和纬度比特<br> 4.生成最终的52位整数作为Sorted Set的score</p><p>为什么选择这种设计？</p><p>高效的范围查询：<br> Geohash 具有&quot;前缀相似性&quot;：附近的位置有相似的hash值<br> 使用ZRANGEBYSCORE可以高效查询附近位置</p><p>内存效率： 相比单独存储经纬度，使用一个score更节省空间 复用已有的Sorted Set数据结构</p><p>计算优化： 距离计算时可以直接解码出原始坐标 使用Haversine公式计算实际距离</p><h3 id="_2-hyperloglog" tabindex="-1"><a class="header-anchor" href="#_2-hyperloglog"><span>2.hyperloglog</span></a></h3><h4 id="_1-介绍-是什么-1" tabindex="-1"><a class="header-anchor" href="#_1-介绍-是什么-1"><span>1.介绍，是什么</span></a></h4><p>HyperLogLog 是 Redis 提供的一种概率性基数统计数据结构，用于高效地估计一个集合中不重复元素的数量（基数统计）。</p><p>核心特点：<br> 极低的内存占用：统计上亿级别的基数只需约 12KB 内存<br> 固定内存消耗：无论统计多少元素，内存占用基本恒定<br> 概率性算法：有约 0.81% 的标准误差<br> 支持合并：多个 HyperLogLog 可以合并计算总基数</p><h4 id="_2-应用场景-1" tabindex="-1"><a class="header-anchor" href="#_2-应用场景-1"><span>2.应用场景</span></a></h4><p>1.大规模的uv统计</p><ul><li>网站uv统计</li><li>文章阅读量</li><li>广告曝光 2.大数据去重</li><li>搜索引擎：统计不同搜索查询的数量</li><li>电商平台：统计不同搜索关键词的数量</li><li>日志分析：统计不同错误类型的出现次数</li></ul><h4 id="_3-底层的数据结构-1" tabindex="-1"><a class="header-anchor" href="#_3-底层的数据结构-1"><span>3.底层的数据结构</span></a></h4><p>有两种编码格式来优化不同场景下的存储</p><p>基本工作流程</p><p>1.哈希计算：对输入元素执行64位哈希（Redis使用MurmurHash64A）如果是稀疏矩阵，则使用32位哈希<br> 2.寄存器选择：前14位作为寄存器索引（2^14=16384个寄存器）<br> 3.前导零计数：计算剩余50位中第一个1出现的位置<br> 4.寄存器更新：如果新值大于当前寄存器值，则更新</p><h3 id="_3-bitmap" tabindex="-1"><a class="header-anchor" href="#_3-bitmap"><span>3.bitmap</span></a></h3><h4 id="_1-介绍-是什么-2" tabindex="-1"><a class="header-anchor" href="#_1-介绍-是什么-2"><span>1.介绍，是什么</span></a></h4><p>Redis的Bitmap实际上是基于String类型实现的，将字符串视为一个由二进制位组成的数组，每个位置可以存储0或1，用来处理二进制的数据</p><h4 id="_2-应用场景-2" tabindex="-1"><a class="header-anchor" href="#_2-应用场景-2"><span>2.应用场景</span></a></h4><ol><li>横向统计 某一个用户存储多个状态值(不推荐)<br> 签到场景为例，用户的id为key，时间为offset偏移值，value为1代表签到，0代表未签到，但是这样维护起来很麻烦，每个用户都要维护一个bitmap</li><li>纵向统计 每个key值作为业务标识，offset为用户的uid (推荐)<br> 比如短视频平台，对每个视频的标识为key，然后uid作为偏移量，value为1代表该用户喜欢该视频，0代表不喜欢该视频</li><li>实现一个简单的布隆过滤器(利用位数组的特性)</li></ol><h4 id="_3-底层的数据结构-2" tabindex="-1"><a class="header-anchor" href="#_3-底层的数据结构-2"><span>3.底层的数据结构</span></a></h4><p>底层数据结构是String</p><p>假设执行</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line">SETBIT mybitmap <span class="token number">10</span> <span class="token number">1</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>内存中的实际存储情况</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">字节偏移量：0        1</span>
<span class="line">bit布局：  00000000 01000000</span>
<span class="line">bit索引：  0-7      8-15</span>
<span class="line">第10位被设为1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自动扩展机制：<br> 当设置的offset超过当前字符串长度时，Redis会自动扩展字符串并用0填充间隙<br> 扩展是以字节为单位的，即使只设置一个bit也可能导致多个字节的分配</p><p>内存预分配：<br> Redis采用预分配策略减少内存重分配次数<br> 每次扩展时可能会分配比实际需要更多的空间</p><p>稀疏位图处理：<br> 对于非常大的offset，Redis会分配中间所有必要的字节<br> 这可能导致稀疏位图实际占用内存比预期大</p><p>与普通String的异同</p><table><thead><tr><th>特性</th><th>Bitmap视角</th><th>String视角</th></tr></thead><tbody><tr><td>存储内容</td><td>二进制位数组</td><td>字节数组</td></tr><tr><td>访问方式</td><td>按bit偏移量</td><td>按字节偏移量</td></tr><tr><td>扩展单位</td><td>bit(实际扩展字节)</td><td>字节</td></tr><tr><td>典型操作</td><td>位运算</td><td>追加、截取等</td></tr></tbody></table><h2 id="redis的缓存更新策略" tabindex="-1"><a class="header-anchor" href="#redis的缓存更新策略"><span>redis的缓存更新策略</span></a></h2><h3 id="_1-cache-aside-pattern-旁路缓存模式" tabindex="-1"><a class="header-anchor" href="#_1-cache-aside-pattern-旁路缓存模式"><span>1.Cache Aside Pattern（旁路缓存模式）</span></a></h3><p>这个模式是我们平常用的比较多的模式，比较适合读请求比较多的情况</p><p>写操作<br> 1.先更新数据库<br> 2.然后直接删除cache<br><img src="https://youke1.picui.cn/s1/2025/07/31/688b64095dfd0.png" alt="图片"></p><p>读操作<br> 1.从 cache 中读取数据，读取到就直接返回<br> 2.cache 中读取不到的话，就从 db 中读取数据返回<br> 3.再把数据放到 cache 中。</p><p>疑问点 1.在写数据的过程中，可以先删除 cache ，后更新 db 么？ ·</p><p>不可以！很有可能发生缓存不一致的问题</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt; 请求 1 再把 db 中的 A 数据更新</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>请求1先删除A的缓存，此时数据还没更新，这时候请求2从db中读取数据(此时请求1的数据库还没更新)，这个时候cache就会有数据了<br> 然后请求1中的db更新了，但是缓存已经存在了。就会导致redis的缓存是未更新的数据，mysql的数据是更新后的数据。</p><p>2.在写数据的过程中，先更新db，再删除redis的缓存，就一定没有问题吗？</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） </span>
<span class="line">-&gt; 请求 1 将数据 A 写入 cache</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>目前在redis的cache中没有缓存，请求1从db中读数据，然后在redis写数据(在写数据之前mysql的db进行了更新，而且因为此时缓存中没有A，也不用删除)，这样的话，用的缓存数据就是更新前的数据了</p><p>但这种情况几乎不存在，因为reids在内存中写，会比mysql快很多。</p><p>缺陷 1：首次请求数据一定不在 cache 的问题解决办法：可以将热点数据可以提前放入 cache 中。<br> 缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。 解决办法：数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。 可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</p><h3 id="_2-read-write-through-pattern-读写穿透" tabindex="-1"><a class="header-anchor" href="#_2-read-write-through-pattern-读写穿透"><span>2.Read/Write Through Pattern（读写穿透）</span></a></h3><p>Read/Write Through 是一种将缓存作为主要数据访问层的设计模式，应用程序只与缓存交互，缓存系统自身负责与底层数据库的数据同步。</p><h4 id="_1-读穿透-read-through" tabindex="-1"><a class="header-anchor" href="#_1-读穿透-read-through"><span>1.读穿透 (Read Through)</span></a></h4><p>应用程序直接向缓存请求数据<br> 如果缓存命中，直接返回数据<br> 如果缓存未命中：<br> 缓存系统自动从数据库加载数据<br> 将数据存入缓存<br> 返回给应用程序</p><h4 id="_2-写穿透-write-through" tabindex="-1"><a class="header-anchor" href="#_2-写穿透-write-through"><span>2.写穿透 (Write Through)</span></a></h4><p>应用程序向缓存写入数据<br> 缓存系统先更新自身数据<br> 缓存系统同步将数据写入数据库<br> 返回写入结果给应用程序</p><h4 id="_3-架构图" tabindex="-1"><a class="header-anchor" href="#_3-架构图"><span>3.架构图</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line"> 应用程序 → [ 缓存 ] ↔ 数据库</span>
<span class="line">              ↖______ ↙</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-优点分析" tabindex="-1"><a class="header-anchor" href="#_4-优点分析"><span>4.优点分析</span></a></h4><p>简化应用逻辑：应用不需要关心缓存与数据库的同步问题<br> 数据一致性：写操作保证缓存和数据库同步更新</p><blockquote><p>当应用程序执行 写操作（如更新数据） 时，缓存层（如 Redis）不会立即返回成功，而是会 同步等待数据库（如 MySQL）也更新完成，确保缓存和数据库的数据完全一致后，才向应用程序返回成功响应。 减少代码重复：避免在每个业务逻辑中重复缓存处理代码</p></blockquote><p>缺点与挑战 实现复杂度：需要封装缓存层，对现有架构改造较大<br> 写性能：每次写操作都需要等待数据库IO完成<br> 缓存系统依赖：缓存系统需要了解数据库schema</p><p>适用场景<br> 读多写少的系统 需要强一致性的业务场景 希望简化应用层代码的项目</p><h3 id="_3-write-behind-pattern-异步缓存写入" tabindex="-1"><a class="header-anchor" href="#_3-write-behind-pattern-异步缓存写入"><span>3.Write Behind Pattern（异步缓存写入）</span></a></h3><p>Write Behind Caching 是一种以缓存为中心的高性能写入策略，其核心哲学是：&quot;先快速响应，后异步持久化&quot;。这种模式将缓存视为事实上的数据源，而数据库则作为备份存储，通过异步方式保持最终一致性。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">[应用程序] → [缓存层] ⇢ [异步队列] → [数据库]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>写入路径：应用 → 缓存 → 确认响应 → (异步) → 数据库</p><p>读取路径：应用 ← 缓存 (始终从缓存读取最新数据)</p><p>写入过程<br> 1.应用发起写请求<br> 2.系统立即更新缓存数据<br> 3.记录变更到写缓冲区/队列<br> 4.立即返回成功响应<br> 5.后台线程定期批量处理缓冲区数据：<br> 6.合并相同key的多次更新<br> 7.批量写入数据库<br> 8.清理已处理的缓冲区条目</p><p>读取过程<br> 1.应用发起读请求<br> 2.直接从缓存返回最新数据（无论是否已持久化到数据库）</p><p>潜在挑战<br> 数据丢失风险：系统崩溃时未持久化的数据会丢失<br> 一致性妥协：无法保证数据库实时反映最新状态<br> 复杂度增加：需要处理故障恢复和缓冲区管理<br> 监控难度：需要额外监控缓存-数据库延迟</p><p>适用场景<br> 写密集型系统：如点击流、日志收集<br> 允许数据丢失的场景：如实时统计、行为分析<br> 突发写入高峰：需要缓冲消峰的场景<br> 非关键业务数据：如社交媒体的点赞、浏览计数</p><h2 id="redis的最终一致性" tabindex="-1"><a class="header-anchor" href="#redis的最终一致性"><span>redis的最终一致性</span></a></h2><h3 id="_1-延迟双删策略" tabindex="-1"><a class="header-anchor" href="#_1-延迟双删策略"><span>(1) 延迟双删策略</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">// 1. 先删除缓存</span></span>
<span class="line">redis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 2. 更新数据库</span></span>
<span class="line">db<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 3. 休眠一段时间(如500ms)后再次删除缓存</span></span>
<span class="line"><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">redis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-基于消息队列的最终一致性" tabindex="-1"><a class="header-anchor" href="#_2-基于消息队列的最终一致性"><span>(2) 基于消息队列的最终一致性</span></a></h3><p>数据库更新后发送消息到MQ<br> 消费者接收消息删除缓存<br> 失败时可重试</p><h3 id="_3-基于binlog的同步" tabindex="-1"><a class="header-anchor" href="#_3-基于binlog的同步"><span>(3) 基于binlog的同步</span></a></h3><p>使用Canal等工具监听数据库binlog<br> 解析变更日志后删除/更新缓存</p><h3 id="选择策略的建议" tabindex="-1"><a class="header-anchor" href="#选择策略的建议"><span>选择策略的建议</span></a></h3><p>强一致性要求：使用分布式锁+同步双写，但性能较低<br> 最终一致性可接受：Cache Aside + 延迟双删或消息队列<br> 读多写少：Read Through模式<br> 写多读少：Write Behind模式</p><h2 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化"><span>redis持久化</span></a></h2><p>我们使用reids，默认情况下redis的数据是保存在内存中的，当redis服务重启的时候，数据就会丢失，为了解决这个问题，redis提供了持久化的功能，将数据保存到磁盘中，当redis服务重启的时候，会从磁盘中加载数据，从而实现数据的持久化。</p><p>接下来主要介绍redis的两种持久化方式 RDB和AOF</p><h3 id="_1-rdb" tabindex="-1"><a class="header-anchor" href="#_1-rdb"><span>1.RDB</span></a></h3><p>RDB 是 Redis 的快照式持久化，它会定期将内存中的数据集生成一个二进制快照文件（默认名为 dump.rdb），保存到磁盘。</p><p>触发方式： 手动触发：通过 SAVE（阻塞）或 BGSAVE（后台异步）命令生成快照。<br> 自动触发：在配置文件中设置规则（如 save 900 1 表示 900 秒内至少 1 个键被修改时触发）。</p><p>优点：<br> 高性能：RDB 是二进制文件，恢复速度快。<br> 紧凑存储：文件体积小，适合备份和灾难恢复。<br> 最小化影响：BGSAVE 通过子进程操作，不影响主进程。</p><p>缺点：<br> 可能丢失数据：如果 Redis 崩溃，最后一次快照后的数据会丢失。<br> 大数据量时耗时：生成快照可能占用较多 CPU 和内存。</p><div class="language-conf line-numbers-mode" data-highlighter="prismjs" data-ext="conf"><pre><code class="language-conf"><span class="line">save 900 1      # 15 分钟内至少 1 个键变化</span>
<span class="line">save 300 10     # 5 分钟内至少 10 个键变化</span>
<span class="line">save 60 10000   # 1 分钟内至少 10000 个键变化</span>
<span class="line">dbfilename dump.rdb</span>
<span class="line">dir ./          # 保存路径</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-aof" tabindex="-1"><a class="header-anchor" href="#_2-aof"><span>2.AOF</span></a></h3><p>AOF 记录所有写操作命令（如 SET、DEL），以追加方式写入文件（默认 appendonly.aof）。重启时通过重放命令恢复数据。</p><p>整体流程<br> 命令追加（append）：所有的写命令会追加到 AOF 缓冲区中。<br> 文件写入（write）：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用write函数（系统调用），write将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。<br> 文件同步（fsync）：AOF 缓冲区根据对应的持久化方式（ fsync 策略）向硬盘做同步操作。这一步需要调用 fsync 函数（系统调用）， fsync 针对单个文件操作，对其进行强制硬盘同步，fsync 将阻塞直到写入磁盘完成后返回，保证了数据持久化。<br> 文件重写（rewrite）：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。<br> 重启加载（load）：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</p><p>可以类比为：<br> 文件写入：就像你把重要文件放在了办公桌抽屉里(内存)，拿取方便但不安全<br> 文件同步：就像你把文件锁进了保险柜(磁盘)，安全但存取麻烦</p><p>同步策略（通过 appendfsync 配置）：<br> always：每个命令都同步到磁盘，最安全但性能最低。<br> everysec（默认）：每秒同步一次，平衡性能与安全。<br> no：由操作系统决定同步时机，性能最好但可能丢失数据。</p><p>优点：<br> 高耐久性：最多丢失 1 秒数据（everysec 配置时）。<br> 可读性：AOF 文件是文本格式，便于人工分析。<br> 自动重写：通过 BGREWRITEAOF 压缩冗余命令（如多次修改同一键）。</p><p>缺点：<br> 文件更大：AOF 通常比 RDB 文件大。<br> 恢复慢：重放命令比加载 RDB 慢。</p><div class="language-conf line-numbers-mode" data-highlighter="prismjs" data-ext="conf"><pre><code class="language-conf"><span class="line">appendonly yes</span>
<span class="line">appendfilename &quot;appendonly.aof&quot;</span>
<span class="line">appendfsync everysec</span>
<span class="line">auto-aof-rewrite-percentage 100  # AOF 文件增长 100% 时触发重写</span>
<span class="line">auto-aof-rewrite-min-size 64mb   # AOF 文件最小重写大小</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AOF的重写机制</p><p>AOF（Append Only File）会记录所有写操作命令（如 SET、DEL），随着运行时间增长，AOF 文件会变得越来越大，可能包含大量冗余命令（比如同一个键被多次修改，只有最后一次操作是有效的）。</p><p>AOF 重写的核心目的：<br> 1.压缩 AOF 文件体积，移除冗余命令，只保留最终数据状态所需的最小命令集。<br> 2.提升恢复速度：重写后的 AOF 文件更小，Redis 重启时重放命令更快。</p><p>触发条件</p><div class="language-conf line-numbers-mode" data-highlighter="prismjs" data-ext="conf"><pre><code class="language-conf"><span class="line">auto-aof-rewrite-percentage 100  # AOF 文件比上次重写后增长 100%（即翻倍）</span>
<span class="line">auto-aof-rewrite-min-size 64mb   # AOF 文件至少达到 64MB 才触发重写</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>触发逻辑：<br> Redis 会记录上一次重写后的 AOF 文件大小（如 64MB）。<br> 当当前 AOF 文件大小比上次重写后的体积 增长 100%（即达到 128MB）且文件大小超过 auto-aof-rewrite-min-size（64MB）时，自动触发重写。</p><h3 id="_3-rdb-aof-或者-rdb-aop混合持久化" tabindex="-1"><a class="header-anchor" href="#_3-rdb-aof-或者-rdb-aop混合持久化"><span>3.RDB+AOF 或者 RDB+AOP混合持久化</span></a></h3><h4 id="方案一-同时开启-rdb-aof" tabindex="-1"><a class="header-anchor" href="#方案一-同时开启-rdb-aof"><span>方案一：同时开启 RDB + AOF</span></a></h4><p>工作方式：<br> 定期生成 RDB 快照<br> 同时持续追加 AOF 日志</p><p>优势：<br> RDB 作为基础备份，AOF 作为增量补充<br> 灾难恢复时：先用 RDB 恢复基础数据，再用 AOF 重放最近操作<br> 双重保障，安全性更高</p><h4 id="方案二-rdb-aof-混合持久化-redis-4-0" tabindex="-1"><a class="header-anchor" href="#方案二-rdb-aof-混合持久化-redis-4-0"><span>方案二：RDB-AOF 混合持久化（Redis 4.0+）</span></a></h4><p>工作方式：<br> AOF 文件由两部分组成：<br> 前半部分：RDB 格式的全量数据<br> 后半部分：增量 AOF 格式的命令</p><p>实际应用建议 数据安全性要求极高： 配置：appendfsync always + 定期 RDB 代价：性能影响最大</p><p>平衡安全与性能： 配置：appendfsync everysec + 混合持久化 推荐：大多数生产环境的折中选择</p><p>优势：<br> 兼具 RDB 的快速恢复和 AOF 的数据完整性<br> 文件体积比纯 AOF 小<br> 恢复速度比纯 AOF 快</p><p>整体的恢复流程</p><div class="language-mermaid line-numbers-mode" data-highlighter="prismjs" data-ext="mermaid"><pre><code class="language-mermaid"><span class="line"><span class="token keyword">graph</span> TD</span>
<span class="line">A<span class="token text string">[Redis启动]</span> <span class="token arrow operator">--&gt;</span> B<span class="token text string">{是否存在AOF文件?}</span></span>
<span class="line">B <span class="token arrow operator">--&gt;</span><span class="token label property">|是|</span> C<span class="token text string">[加载AOF文件]</span></span>
<span class="line">B <span class="token arrow operator">--&gt;</span><span class="token label property">|否|</span> D<span class="token text string">[加载RDB文件]</span></span>
<span class="line">C <span class="token arrow operator">--&gt;</span> E<span class="token text string">[如果是混合持久化,先加载RDB部分再重放AOF命令]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-如何选择rbd和aof" tabindex="-1"><a class="header-anchor" href="#_4-如何选择rbd和aof"><span>4.如何选择RBD和AOF</span></a></h3><p>1.一般推荐使用单独的RDB 持久化（如果允许部分数据丢失）</p><p>因为RDB存放的是压缩过的二进制的数据，保存着某个时间点的数据，文件很小，而且恢复数据数据的时候直接解析还原数据即可，恢复起来更快。<br> 如果是AOF的话，需要一条一条的解析命令，文件的内容也会偏大，而且如果数据量大，redis的重写AOF文件的时候，会消耗一定的内存</p><p>2.AOF的的优势<br> aof的操作，更加轻量化一点，每秒写入一次<br> .rdb文件对于老版本会不兼容，数据迁移可能会有问题，但是AOF文件没这个问题<br> AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行FLUSHALL命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</p><p>3.如果要使用rdb，不要只使用rdb，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</p><p>4.如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化</p><h2 id="redis事务-lua脚本" tabindex="-1"><a class="header-anchor" href="#redis事务-lua脚本"><span>redis事务 + Lua脚本</span></a></h2><h3 id="redis事务介绍" tabindex="-1"><a class="header-anchor" href="#redis事务介绍"><span>redis事务介绍</span></a></h3><p>这块了解即可，不用深度学习。<br> Redis 事务是一种将多个命令打包执行的机制，确保这些命令按顺序、一次性、原子性地执行（但非严格意义上的ACID事务）。它通过 MULTI、EXEC、DISCARD 和 WATCH 等命令实现。</p><p>(1) 基本事务流程</p><p>1.MULTI<br> 标记事务开始，后续命令会放入队列，而非立即执行。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token operator">&gt;</span> MULTI</span>
<span class="line">OK</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>2.命令入队 输入的命令会按顺序缓存到队列中，返回 QUEUED 表示成功入队。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token operator">&gt;</span> SET key1 <span class="token string">&quot;value1&quot;</span></span>
<span class="line">QUEUED</span>
<span class="line"><span class="token operator">&gt;</span> INCR key2</span>
<span class="line">QUEUED</span>
<span class="line">EXEC</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.执行事务队列中的所有命令，返回每个命令的结果。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token operator">&gt;</span> EXEC</span>
<span class="line"><span class="token number">1</span><span class="token punctuation">)</span> OK       <span class="token comment"># SET key1 &quot;value1&quot; 的结果</span></span>
<span class="line"><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>  <span class="token comment"># INCR key2 的结果</span></span>
<span class="line">OK</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.DISCARD 取消事务，清空队列，不执行任何命令。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token operator">&gt;</span> DISCARD</span>
<span class="line">OK</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>(2) 事务的原子性</p><p>Redis 事务是原子性的：所有命令在 EXEC 时一次性执行，不会被其他客户端命令打断。<br> 但无回滚机制：如果某个命令失败（如语法错误），其他命令仍会执行（与关系型数据库不同）。</p><p>示例</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token operator">&gt;</span> MULTI</span>
<span class="line">OK</span>
<span class="line"><span class="token operator">&gt;</span> SET key1 <span class="token string">&quot;value1&quot;</span></span>
<span class="line">QUEUED</span>
<span class="line"><span class="token operator">&gt;</span> INCR key1  <span class="token comment"># 错误：对字符串执行INCR</span></span>
<span class="line"><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> key2 <span class="token string">&quot;value2&quot;</span> </span>
<span class="line">QUEUED</span>
<span class="line"><span class="token operator">&gt;</span> EXEC</span>
<span class="line"><span class="token number">1</span><span class="token punctuation">)</span> OK        <span class="token comment"># SET 成功</span></span>
<span class="line"><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR value is not an integer  <span class="token comment"># INCR 失败，但SET已生效</span></span>
<span class="line"><span class="token number">3</span><span class="token punctuation">)</span> OK         <span class="token comment"># SET key2 成功，第二个报错不影响第三个成功</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(3) 乐观锁：WATCH 命令</p><p>Redis 通过 WATCH 实现乐观锁（CAS，Check-And-Set），用于监控键的变化，防止事务执行期间数据被修改。</p><p>如果 WATCH 的键在 MULTI 和 EXEC 之间被修改，事务会自动放弃（返回 nil）。</p><p>完整示例流程参考</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token operator">&gt;</span> WATCH stock</span>
<span class="line">OK</span>
<span class="line"><span class="token operator">&gt;</span> MULTI</span>
<span class="line">OK</span>
<span class="line"><span class="token operator">&gt;</span> DECR stock</span>
<span class="line">QUEUED</span>
<span class="line"><span class="token operator">&gt;</span> EXEC  <span class="token comment"># 如果 stock 未被其他客户端修改，事务成功</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(4) 总结</p><p>Redis 事务通过 MULTI/EXEC 实现批量命令原子执行，但无回滚。</p><p>WATCH 提供乐观锁机制，防止数据竞争。</p><p>适合简单场景，不适合复杂事务需求（需结合 Lua 脚本增强）。</p><h3 id="lua脚本" tabindex="-1"><a class="header-anchor" href="#lua脚本"><span>Lua脚本</span></a></h3><p>Lua脚本呢，就是把redis的操作整合在一个命令里面了，和事务不同，事务是把要执行的多个任务一个一个放到队列里面，然后一起执行，Lua脚本就是执行一个任务。</p><p>学习会基础的Lua脚本</p><div class="language-Lua line-numbers-mode" data-highlighter="prismjs" data-ext="Lua"><pre><code class="language-Lua"><span class="line">-- 变量声明(无需类型声明)</span>
<span class="line">local name = &quot;Alice&quot;  -- 字符串</span>
<span class="line">local age = 30        -- 数字</span>
<span class="line">local isJavaDev = true -- 布尔</span>
<span class="line">local scores = {90, 85, 95} -- 表(类似Java的数组/Map)</span>
<span class="line"></span>
<span class="line">-- 注意: Lua中索引从1开始!</span>
<span class="line">print(scores[1]) -- 输出90</span>
<span class="line"></span>
<span class="line">-- if语句</span>
<span class="line">if age &gt; 18 then</span>
<span class="line">    print(&quot;成年人&quot;)</span>
<span class="line">elseif age &gt; 12 then</span>
<span class="line">    print(&quot;青少年&quot;)</span>
<span class="line">else</span>
<span class="line">    print(&quot;儿童&quot;)</span>
<span class="line">end</span>
<span class="line"></span>
<span class="line">-- for循环</span>
<span class="line">for i = 1, 5 do</span>
<span class="line">    print(&quot;计数: &quot; .. i)  -- .. 是字符串连接</span>
<span class="line">end</span>
<span class="line"></span>
<span class="line">-- while循环</span>
<span class="line">local count = 0</span>
<span class="line">while count &lt; 3 do</span>
<span class="line">    print(&quot;while循环: &quot; .. count)</span>
<span class="line">    count = count + 1</span>
<span class="line">end</span>
<span class="line"></span>
<span class="line">-- 定义函数</span>
<span class="line">function add(a, b)</span>
<span class="line">    return a + b</span>
<span class="line">end</span>
<span class="line"></span>
<span class="line">-- 调用函数</span>
<span class="line">local result = add(5, 3)</span>
<span class="line">print(&quot;5 + 3 = &quot; .. result)</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单调用实战</p><p>Lua脚本如下</p><div class="language-lua line-numbers-mode" data-highlighter="prismjs" data-ext="lua"><pre><code class="language-lua"><span class="line"><span class="token comment">-- 简单示例: 设置并获取值</span></span>
<span class="line"><span class="token keyword">local</span> key <span class="token operator">=</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment">-- 获取第一个键参数</span></span>
<span class="line"><span class="token keyword">local</span> value <span class="token operator">=</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">-- 获取第一个值参数</span></span>
<span class="line">redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;SET&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;GET&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际在redis-cli的操作与讲解</p><div class="language-redis line-numbers-mode" data-highlighter="prismjs" data-ext="redis"><pre><code class="language-redis"><span class="line"># EVAL 就是代表着执行这个脚本</span>
<span class="line"># 1 表示 KEYS 数组的长度，mykey 表示 KEYS 数组中的第一个元素，hello 表示 ARGV 数组中的第一个元素</span>
<span class="line"># KEYS[1] 表示 mykey, ARGV[1] 表示 hello</span>
<span class="line">EVAL &quot;local key = KEYS[1] local value = ARGV[1] redis.call(&#39;SET&#39;, key, value) return redis.call(&#39;GET&#39;, key)&quot; 1 mykey &quot;hello&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接在java中写逻辑和使用Lua脚本的优劣</p><p>先简单的实现一个限流器</p><div class="language-lua line-numbers-mode" data-highlighter="prismjs" data-ext="lua"><pre><code class="language-lua"><span class="line"><span class="token keyword">local</span> key <span class="token operator">=</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span>
<span class="line"><span class="token keyword">local</span> time <span class="token operator">=</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">local</span> count <span class="token operator">=</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">local</span> current <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">if</span> current <span class="token keyword">and</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token operator">&gt;</span>count <span class="token keyword">then</span>    </span>
<span class="line">　　<span class="token keyword">return</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">end</span></span>
<span class="line">current <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;incr&#39;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token keyword">then</span>    </span>
<span class="line">　　redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;expire&#39;</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>time<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">end</span></span>
<span class="line"><span class="token keyword">return</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java"><pre><code class="language-Java"><span class="line">public boolean isExceedLimit(String key, int expireSeconds, int limit) {</span>
<span class="line">    // 1. 获取当前计数</span>
<span class="line">    Long current = redisTemplate.opsForValue().increment(key, 1);</span>
<span class="line">    </span>
<span class="line">    // 2. 首次请求设置过期时间</span>
<span class="line">    if (current != null &amp;&amp; current == 1) {</span>
<span class="line">        redisTemplate.expire(key, expireSeconds, TimeUnit.SECONDS);</span>
<span class="line">    }</span>
<span class="line">    </span>
<span class="line">    // 3. 判断是否超限</span>
<span class="line">    if (current != null &amp;&amp; current &gt; limit) {</span>
<span class="line">        return true; // 触发限流</span>
<span class="line">    }</span>
<span class="line">    return false;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结论：Java 实现的局限性</p><p>在分布式高并发环境中，Java 实现存在两大根本问题：</p><p>时间窗口漂移：</p><p>多个请求可能设置过期时间<br> 导致实际时间窗口长度不稳定</p><p>永久键风险：</p><p>当第一个请求设置过期时间失败时<br> 键可能变为永久存在<br> 导致永久性限流故障</p><p>何时使用 Java 实现：</p><p>低并发场景 允许少量计数误差<br> 有外部监控可检测永久键问题<br> 无法使用 Lua 脚本的环境</p><p>Lua 解决的核心问题：</p><p>真正的原子操作：</p><p>检查计数 → 自增 → 设置过期时间 在单次操作中完成<br> 无并发干扰可能</p><p>精确的首次判断：</p><p>if tonumber(current) == 1 在自增后判断<br> 确保只有一个请求设置过期时间</p><p>超限提前返回：<br> 如果已超限，不执行自增操作<br> 避免无效计数增加</p><p>总结：</p><table><thead><tr><th><strong>考虑维度</strong></th><th><strong>Lua脚本</strong></th><th><strong>Java实现</strong></th></tr></thead><tbody><tr><td><strong>原子性</strong></td><td>✅ 完美保证</td><td>❌ 需额外手段（事务、分布式锁）</td></tr><tr><td><strong>网络开销</strong></td><td>✅ 极低（1次往返）</td><td>❌ 高（多次往返）</td></tr><tr><td><strong>Redis阻塞风险</strong></td><td>⚠️ 可能（脚本过长时）</td><td>✅ 低（每个命令快速）</td></tr><tr><td><strong>开发调试</strong></td><td>❌ 困难</td><td>✅ 简单（集成IDE、日志）</td></tr><tr><td><strong>可维护性</strong></td><td>⚠️ 中（需管理脚本版本）</td><td>✅ 高（Java代码易管理）</td></tr><tr><td><strong>兼容性</strong></td><td>⚠️ 依赖Redis版本和集群设置</td><td>✅ 高（命令通用）</td></tr><tr><td><strong>错误处理</strong></td><td>❌ 脚本出错影响大</td><td>✅ 灵活（可捕获异常重试）</td></tr><tr><td><strong>适用场景</strong></td><td>高并发、原子性要求高、网络延迟大的场景</td><td>低频、简单逻辑、需要与业务紧密集成的场景</td></tr></tbody></table><h2 id="redis性能优化" tabindex="-1"><a class="header-anchor" href="#redis性能优化"><span>redis性能优化</span></a></h2><h3 id="_1-批量优化" tabindex="-1"><a class="header-anchor" href="#_1-批量优化"><span>1.批量优化</span></a></h3><p>一个 Redis 命令的执行可以简化为以下 4 步：</p><p>发送命令；<br> 命令排队；<br> 命令执行；<br> 返回结果。</p><p>其中，第 1 步和第 4 步耗费时间之和称为 Round Trip Time（RTT，往返时间），也就是数据在网络上传输的时间。 使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p><h4 id="_1-原生批量操作" tabindex="-1"><a class="header-anchor" href="#_1-原生批量操作"><span>1.原生批量操作</span></a></h4><div class="language-Redis line-numbers-mode" data-highlighter="prismjs" data-ext="Redis"><pre><code class="language-Redis"><span class="line">String类型  (MSET / MGET)</span>
<span class="line">MSET key1 &quot;value1&quot; key2 &quot;value2&quot;  # 批量设置</span>
<span class="line">MGET key1 key2                    # 批量获取 → [&quot;value1&quot;, &quot;value2&quot;]</span>
<span class="line"></span>
<span class="line">Hash类型 (HMSET / HMGET)</span>
<span class="line">HSET user:1000 name &quot;Alice&quot; age 30    # 批量设置（HSET替代HMSET）</span>
<span class="line">HMGET user:1000 name age             # 批量获取 → [&quot;Alice&quot;, &quot;30&quot;]</span>
<span class="line"></span>
<span class="line">List类型 (LPUSH / RPUSH)</span>
<span class="line">LPUSH mylist &quot;a&quot; &quot;b&quot; &quot;c&quot;  # 列表顺序 → [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
<span class="line">RPUSH mylist &quot;x&quot; &quot;y&quot;      # 列表顺序 → [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;x&quot;, &quot;y&quot;]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-pipeline批量操作" tabindex="-1"><a class="header-anchor" href="#_2-pipeline批量操作"><span>2.pipeline批量操作</span></a></h4><p>pipeline 是一种将多个命令一次性发送给 Redis 服务器的方式，从而减少网络传输次数，提高性能。</p><p>需要注意的是，pipeline和redis的事务是不同的概念 事务是原子操作(但不保证原子性)，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。 Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java"><pre><code class="language-Java"><span class="line">Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);</span>
<span class="line">Pipeline pipe = jedis.pipelined();</span>
<span class="line"></span>
<span class="line">// 添加命令</span>
<span class="line">pipe.set(&quot;key1&quot;, &quot;value1&quot;);</span>
<span class="line">pipe.get(&quot;key1&quot;);</span>
<span class="line">pipe.hset(&quot;user:1000&quot;, &quot;name&quot;, &quot;Alice&quot;);</span>
<span class="line">pipe.hgetAll(&quot;user:1000&quot;);</span>
<span class="line"></span>
<span class="line">// 同步发送并获取响应（返回 List&lt;Object&gt;）</span>
<span class="line">List&lt;Object&gt; results = pipe.syncAndReturnAll();</span>
<span class="line">System.out.println(results);  // [OK, value1, 1, {name=Alice}]</span>
<span class="line"></span>
<span class="line">jedis.close();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-lua脚本" tabindex="-1"><a class="header-anchor" href="#_3-lua脚本"><span>3.Lua脚本</span></a></h4><p>Lua 脚本同样支持批量操作多条命令。 一段 Lua 脚本可以视作一条命令执行，可以看作是 原子操作。 也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p><p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。 不过， Lua 脚本依然存在下面这些缺陷：如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</p><p>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 hash slot（哈希槽） 上。</p><h3 id="_2-bigkey优化" tabindex="-1"><a class="header-anchor" href="#_2-bigkey优化"><span>2.BigKey优化</span></a></h3><h4 id="_1-识别方法" tabindex="-1"><a class="header-anchor" href="#_1-识别方法"><span>1.识别方法</span></a></h4><div class="language-redis line-numbers-mode" data-highlighter="prismjs" data-ext="redis"><pre><code class="language-redis"><span class="line"># 扫描大 Key（生产环境慎用）</span>
<span class="line">redis-cli --bigkeys</span>
<span class="line"></span>
<span class="line"># 内存分析</span>
<span class="line">redis-cli memory usage &lt;key&gt;  # 查看单个 Key 内存占用</span>
<span class="line">redis-cli memory stats         # 全局内存分析</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>数据类型</th><th>bigKey阈值</th></tr></thead><tbody><tr><td>String</td><td>&gt; 10 KB</td></tr><tr><td>Hash</td><td>&gt; 1000 个字段</td></tr><tr><td>List</td><td>&gt; 1000 个元素</td></tr><tr><td>Set/ZSet</td><td>&gt; 1000 个成员</td></tr></tbody></table><h4 id="_1-数据拆分" tabindex="-1"><a class="header-anchor" href="#_1-数据拆分"><span>1.数据拆分</span></a></h4><p>垂直拆分</p><div class="language-redis line-numbers-mode" data-highlighter="prismjs" data-ext="redis"><pre><code class="language-redis"><span class="line"># 原始大 Key: user:1000_data (包含 profile, orders, logs 等)</span>
<span class="line"># 拆分后:</span>
<span class="line">HSET user:1000:profile name &quot;Alice&quot; age 30</span>
<span class="line">RPUSH user:1000:orders &quot;order1&quot; &quot;order2&quot;</span>
<span class="line">SET user:1000:logs &quot;log_data...&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>水平拆分/分片</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java"><pre><code class="language-Java"><span class="line">// Java 分片示例</span>
<span class="line">int shardCount = 16; // 分片数</span>
<span class="line">String key = &quot;big_hash_key&quot;;</span>
<span class="line"></span>
<span class="line">// 写入分片</span>
<span class="line">String field = &quot;field123&quot;;</span>
<span class="line">int shardIndex = field.hashCode() % shardCount;</span>
<span class="line">redis.hset(key + &quot;:&quot; + shardIndex, field, value);</span>
<span class="line"></span>
<span class="line">// 读取分片</span>
<span class="line">String value = redis.hget(key + &quot;:&quot; + shardIndex, field);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-数据压缩" tabindex="-1"><a class="header-anchor" href="#_2-数据压缩"><span>2.数据压缩</span></a></h4><p>使用 Gzip/Snappy 压缩文本数据</p><p>二进制数据用 Protocol Buffers/MessagePack 序列化</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java"><pre><code class="language-Java"><span class="line">// Gzip 压缩</span>
<span class="line">public byte[] compress(String data) throws IOException {</span>
<span class="line">    ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="line">    try (GZIPOutputStream gzip = new GZIPOutputStream(bos)) {</span>
<span class="line">        gzip.write(data.getBytes());</span>
<span class="line">    }</span>
<span class="line">    return bos.toByteArray();</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// Redis 存储</span>
<span class="line">byte[] compressed = compress(largeJson);</span>
<span class="line">redis.set(&quot;compressed_key&quot;.getBytes(), compressed); </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-数据结构优化" tabindex="-1"><a class="header-anchor" href="#_3-数据结构优化"><span>3.数据结构优化</span></a></h4><table><thead><tr><th>原数据结构</th><th>问题</th><th>优化方案</th><th>优势</th></tr></thead><tbody><tr><td>大 List</td><td>线性搜索慢</td><td>改用 ZSet + 时间戳分页</td><td>O(logN) 复杂度</td></tr><tr><td>大 Set</td><td>交集/并集操作慢</td><td>改用 Bloom Filter</td><td>节省 90% 内存</td></tr><tr><td>大 String</td><td>修改成本高</td><td>分块存储</td><td>局部更新</td></tr><tr><td>大 Hash</td><td>hgetall 阻塞</td><td>分片存储 + hscan</td><td>按需读取</td></tr></tbody></table><div class="language-redis line-numbers-mode" data-highlighter="prismjs" data-ext="redis"><pre><code class="language-redis"><span class="line"># 原始 List 分页 (低效)</span>
<span class="line">LRANGE big_list 0 9</span>
<span class="line"></span>
<span class="line"># 优化为 ZSet (按时间排序)</span>
<span class="line">ZADD big_zset 1640995200 &quot;item1&quot; 1641081600 &quot;item2&quot;</span>
<span class="line">ZREVRANGE big_zset 0 9 WITHSCORES  # 获取最新10条</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-redis line-numbers-mode" data-highlighter="prismjs" data-ext="redis"><pre><code class="language-redis"><span class="line">Set	交集/并集操作慢</span>
<span class="line"># 创建容量100万，误判率1%的布隆过滤器</span>
<span class="line">BF.RESERVE user_filter 0.01 1000000</span>
<span class="line"></span>
<span class="line"># 添加元素</span>
<span class="line">BF.ADD user_filter user123</span>
<span class="line">BF.ADD user_filter user456</span>
<span class="line"></span>
<span class="line"># 检查是否存在</span>
<span class="line">BF.EXISTS user_filter user123  # 返回1（可能存在）</span>
<span class="line">BF.EXISTS user_filter user999  # 返回0（肯定不存在）</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>渐进式删除</p><div class="language-redis line-numbers-mode" data-highlighter="prismjs" data-ext="redis"><pre><code class="language-redis"><span class="line"># 非阻塞删除 (Redis 4.0+)</span>
<span class="line">UNLINK big_key</span>
<span class="line"></span>
<span class="line"># 渐进式删除 Hash</span>
<span class="line">HSCAN big_hash 0 COUNT 100 | while read field; do </span>
<span class="line">    HDEL big_hash $field </span>
<span class="line">done</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-hotkey优化" tabindex="-1"><a class="header-anchor" href="#_3-hotkey优化"><span>3.HotKey优化</span></a></h3><p>如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 hotkey（热 Key）。</p><p>例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。</p><p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。 此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。</p><p>这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p><div class="language-redis line-numbers-mode" data-highlighter="prismjs" data-ext="redis"><pre><code class="language-redis"><span class="line">redis-cli --hotkeys              # Redis 4.0+（需开启 LFU 统计）</span>
<span class="line">redis-cli info commandstats      # 查看命令调用频次</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法</p><p>读写分离：主节点处理写请求，从节点处理读请求。<br> 使用 Redis Cluster：将热点数据分散存储在多个 Redis 节点上。<br> 二级缓存：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><time class="meta-item-info" datetime="2025-08-11T08:52:48.000Z" data-allow-mismatch>8/11/25, 8:52 AM</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: major@2025">hmw</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: 11961954+hlknb123@user.noreply.gitee.com">何力凯</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/blog/assets/app-l44R1w7S.js" defer></script>
  </body>
</html>
