import{_ as e,c as a,a as l,o as n}from"./app-DtVsJ4Vi.js";const i="/blog/assets/img-CAM3VjXe.png",r="/blog/assets/img1-CUBSMW7R.png",t="/blog/assets/img2-BSVJmrCW.png",o={};function p(m,s){return n(),a("div",null,[...s[0]||(s[0]=[l('<h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql"><span>Mysql</span></a></h1><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>本文档记录的主要有 <strong>常见八股文</strong> + <strong>底层的原理</strong> + <strong>SQL优化案例汇总</strong></p><p>主要是根据黑马程序员的b站视频的mysql部分进行总结，对底层相关进行进一步分析</p><p>总体架构如下 <img src="'+i+`" alt="img.png"></p><h2 id="如何定位慢查询" tabindex="-1"><a class="header-anchor" href="#如何定位慢查询"><span>如何定位慢查询</span></a></h2><p>常见查询比较慢的场景</p><ul><li>聚合查询</li><li>多表查询</li><li>表数据量过大查询</li><li>深度分页查询</li></ul><p>具体现象：页面加载过慢，接口压测的响应时间过长 (1s)</p><p>方法一:开源工具</p><ul><li>调试工具: Arthas</li><li>运维工具: Prometheus、SkyWalking</li></ul><p>方法二: Mysql自带的慢日志 慢日志查询记录了所有执行时间超过指定参数(long_query_time,单位:秒,默认10s)的所有sql日志 如果要开启慢查询日志，选哟在Mysql的配置文件(/etc/my.cnf)中配置</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token comment"># 开启慢日志查询的开关</span></span>
<span class="line">slow_query_logs <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"><span class="token comment"># 设置慢日志查询的时间,超过这个时间就放到slow.log中</span></span>
<span class="line">long_query_time <span class="token operator">=</span> <span class="token number">2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+r+'" alt="img.png"></p><p>标准回答<br> 1.介绍以下当时产生问题的场景(我们当hi的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br> 2.我们系统中当时采用了运维工具Skywalking，可以检测出哪个接口，最后因为是sql的原因<br> 3.在mysql中开启了慢日志擦汗寻，我们设置的值就是2秒，一旦sql执行超过2秒就会记录道日志中</p><h2 id="如何分析慢查询" tabindex="-1"><a class="header-anchor" href="#如何分析慢查询"><span>如何分析慢查询</span></a></h2><p>可以通过explain命令获取mysql如何执行select的信息</p><p><img src="'+t+'" alt="img.png"></p><p>主要字段分析</p><ul><li>possible_key 当前sql可能会使用到的索引 (不用管这个)</li><li>key 当前sql实际命中的索引</li><li>key_len 索引占用的大小 (一般看这两个查看是否可能会命中索引)</li><li>extra 额外的优化建议 (主要是针对要不要回表查询)</li><li>type 这跳sql的链接的类型，性能由好到差为null、system、const、eq_ref、ref、range、index、all</li></ul><blockquote><p>system：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。<br> const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。<br> eq_ref：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。<br> ref：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。<br> range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。<br> index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。<br> ALL：全表扫描。</p></blockquote><ul><li>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好</li><li>extra mysql的一些额外的建议</li></ul><blockquote><p>Using filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。<br> Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。<br> Using index：表明查询使用了覆盖索引，不用回表，查询效率非常高。<br> Using index condition：表示查询优化器选择使用了索引条件下推这个特性。<br> Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。<br> Using join buffer (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。<br> 这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p></blockquote><p>标准回答 可以采用mysql自带的分析工具explain</p><ul><li>通过key和ken_len来检查是否命中了索引(索引本身存在失效的情况)</li><li>通过type字段来查看sql是否由进一步的优化空间，是否存在全索引扫描或者全盘扫描</li><li>通过extra建议判断，是否出现外部排序，采用临时表再来存储查询的数据，出现回表的情况，可以尝试添加索引，修改返回字段来实现。</li></ul><h2 id="索引概念与索引的底层结构" tabindex="-1"><a class="header-anchor" href="#索引概念与索引的底层结构"><span>索引概念与索引的底层结构</span></a></h2><p>索引(index) 是帮助mysql搞笑获取数据的数据结构(有序)。 在数据之外，数据库系统还维护着满足特定查找算法的数据结构(B+树)，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>常见的几种数据结构的缺陷</p><p>二叉搜索树: 极端情况下可能会出现单链表的情况，<br> 红黑树：分支有限，在数据量大的情况下树会很高，导致磁盘io变多。 b树(多路平衡查找树)：</p>',29)])])}const d=e(o,[["render",p],["__file","mysql.html.vue"]]),b=JSON.parse('{"path":"/backend/mysql.html","title":"Mysql","lang":"zn-ch","frontmatter":{},"git":{"updatedTime":1753888698000,"contributors":[{"name":"晴为镜","username":"","email":"11961954+hlknb123@user.noreply.gitee.com","commits":2},{"name":"何力凯","username":"","email":"194671581@qq.com","commits":2}],"changelog":[{"hash":"95ddafe2a9f5163d1d1e41e5c11ad5c8b42a3478","time":1753888698000,"email":"11961954+hlknb123@user.noreply.gitee.com","author":"何力凯","message":"redis的特殊数据结构"},{"hash":"8be9c039b01f043db54dcd2b36fc5f2e1a786cbf","time":1748521683000,"email":"11961954+hlknb123@user.noreply.gitee.com","author":"晴为镜","message":"补充"},{"hash":"da451c0485b6abd3da0350045a6115857e337a7d","time":1739858117000,"email":"194671581@qq.com","author":"何力凯","message":"微服务相关添加"},{"hash":"a73f23f50d1631006f765b178fa52240d9cefb42","time":1734692017000,"email":"11961954+hlknb123@user.noreply.gitee.com","author":"晴为镜","message":"mysql的部分增加"}]},"filePathRelative":"backend/mysql.md"}');export{d as comp,b as data};
