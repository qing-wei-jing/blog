import{_ as n,c as s,a as e,o as p}from"./app-CF0q375B.js";const t={};function l(i,a){return p(),s("div",null,[...a[0]||(a[0]=[e(`<h1 id="spring-中-bean-的几种注入方式详解" tabindex="-1"><a class="header-anchor" href="#spring-中-bean-的几种注入方式详解"><span>Spring 中 Bean 的几种注入方式详解</span></a></h1><p>本文中的代码已上传github，可以自行下载运行体验，如果可以，记得点个star！阿里嘎多</p><p>https://github.com/qing-wei-jing/bean-injection-demo</p><p>在 Spring 框架中，Bean 的注入是依赖注入（Dependency Injection, DI）的核心实现方式，它帮助我们解耦组件之间的依赖关系，提高代码的灵活性和可维护性。本文将结合实际代码示例，详细介绍 Spring 中常见的几种 Bean 注入方式。</p><h2 id="一、什么是-bean-注入" tabindex="-1"><a class="header-anchor" href="#一、什么是-bean-注入"><span>一、什么是 Bean 注入</span></a></h2><p>Bean 注入是指 Spring 容器在创建 Bean 时，自动将其依赖的其他 Bean 赋值给当前 Bean 的过程。通过依赖注入，我们无需手动创建依赖对象，而是由 Spring 容器负责管理和装配，这也是控制反转（IoC）思想的具体体现。</p><h2 id="二、常见的-bean-注入方式" tabindex="-1"><a class="header-anchor" href="#二、常见的-bean-注入方式"><span>二、常见的 Bean 注入方式</span></a></h2><h3 id="_1-autowired-注解注入" tabindex="-1"><a class="header-anchor" href="#_1-autowired-注解注入"><span>1. @Autowired 注解注入</span></a></h3><p><code>@Autowired</code>是 Spring 框架提供的注解，默认按照类型（byType）进行注入。当容器中存在多个同类型的 Bean 时，需要配合<code>@Qualifier</code>注解按名称（byName）注入。</p><h4 id="_1-1-按类型注入-bytype" tabindex="-1"><a class="header-anchor" href="#_1-1-按类型注入-bytype"><span>1.1 按类型注入（byType）</span></a></h4><p>直接使用<code>@Autowired</code>注解在字段上，Spring 会自动寻找匹配类型的 Bean 进行注入：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@Autowired</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">Hello1ServiceImpl</span> hello1Service<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时变量名可以任意命名，因为 Spring 是通过类型匹配的。</p><h4 id="_1-2-按名称注入-byname" tabindex="-1"><a class="header-anchor" href="#_1-2-按名称注入-byname"><span>1.2 按名称注入（byName）</span></a></h4><p>当存在多个同接口的实现类时，需要结合<code>@Qualifier</code>指定 Bean 的名称：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@Autowired</span></span>
<span class="line"><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">&quot;hello2ServiceImpl&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">MessageService</span> hello2Service<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里<code>@Qualifier</code>的值需要与目标 Bean 的名称一致（默认情况下，类名首字母小写即为 Bean 名）。</p><h3 id="_2-resource-注解注入" tabindex="-1"><a class="header-anchor" href="#_2-resource-注解注入"><span>2. @Resource 注解注入</span></a></h3><p><code>@Resource</code>是 JDK 提供的注解（位于 jakarta.annotation 包下），默认按照名称（byName）进行注入，也可以通过属性指定类型或名称。</p><h4 id="_2-1-默认按名称注入" tabindex="-1"><a class="header-anchor" href="#_2-1-默认按名称注入"><span>2.1 默认按名称注入</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@Resource</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">MessageService</span> hello3ServiceImpl<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时 Spring 会根据变量名<code>hello3ServiceImpl</code>去匹配对应的 Bean。</p><h4 id="_2-2-指定类型和名称注入" tabindex="-1"><a class="header-anchor" href="#_2-2-指定类型和名称注入"><span>2.2 指定类型和名称注入</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">Hello4ServiceImpl</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">&quot;hello4ServiceImpl&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">MessageService</span> hello4Service<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>type</code>属性指定 Bean 的类型，<code>name</code>属性指定 Bean 的名称，实现精确匹配。</p><h3 id="_3-setter-方法注入" tabindex="-1"><a class="header-anchor" href="#_3-setter-方法注入"><span>3. Setter 方法注入</span></a></h3><p>Setter 注入是通过 Setter 方法实现依赖注入，本质上还是按类型匹配，通常配合<code>@Autowired</code>注解使用：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">private</span> <span class="token class-name">MessageService</span> hello5Service<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation punctuation">@Autowired</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHello5Service</span><span class="token punctuation">(</span><span class="token class-name">Hello5ServiceImpl</span> hello5Service<span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>hello5Service <span class="token operator">=</span> hello5Service<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring 容器会调用该 Setter 方法，将匹配的 Bean 注入到当前对象中。</p><h3 id="_4-构造器注入" tabindex="-1"><a class="header-anchor" href="#_4-构造器注入"><span>4. 构造器注入</span></a></h3><p>构造器注入是通过构造方法实现依赖注入，当 Bean 实例化时，Spring 会通过构造方法将依赖的 Bean 传入。</p><h4 id="_4-1-基本构造器注入" tabindex="-1"><a class="header-anchor" href="#_4-1-基本构造器注入"><span>4.1 基本构造器注入</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Hello6ServiceImpl</span> hello6Service<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">InjectionDemoController</span><span class="token punctuation">(</span><span class="token class-name">Hello6ServiceImpl</span> hello6Service<span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>hello6Service <span class="token operator">=</span> hello6Service<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构造器注入的优势在于可以将依赖设置为<code>final</code>，保证依赖不可变，同时确保在对象创建时就完成依赖注入。</p><h4 id="_4-2-批量构造器注入-配合-lombok" tabindex="-1"><a class="header-anchor" href="#_4-2-批量构造器注入-配合-lombok"><span>4.2 批量构造器注入（配合 Lombok）</span></a></h4><p>当需要注入多个依赖时，可以使用 Lombok 的<code>@RequiredArgsConstructor</code>注解简化代码：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@RestController</span></span>
<span class="line"><span class="token annotation punctuation">@RequiredArgsConstructor</span></span>
<span class="line"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;/constructor&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstructorInjectionDemoController</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Hello1ServiceImpl</span> hello1Service<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Hello2ServiceImpl</span> hello2Service<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Hello3ServiceImpl</span> hello3Service<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 更多依赖...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@RequiredArgsConstructor</code>会为所有<code>final</code>修饰的字段生成对应的构造方法，无需手动编写，极大简化了构造器注入的代码。</p><h2 id="三、各种注入方式的对比与推荐" tabindex="-1"><a class="header-anchor" href="#三、各种注入方式的对比与推荐"><span>三、各种注入方式的对比与推荐</span></a></h2><table><thead><tr><th>注入方式</th><th>优点</th><th>缺点</th><th>推荐场景</th></tr></thead><tbody><tr><td>@Autowired</td><td>使用简单，Spring 原生支持</td><td>依赖 Spring 框架，默认按类型注入可能产生歧义</td><td>快速开发，依赖关系简单</td></tr><tr><td>@Resource</td><td>JDK 标准，不依赖 Spring，默认按名称注入</td><td>功能相对单一</td><td>希望减少对 Spring 框架的依赖</td></tr><tr><td>Setter 注入</td><td>灵活性高，可在对象创建后修改依赖</td><td>无法将依赖设为 final，可能导致对象状态不一致</td><td>需要在运行时修改依赖</td></tr><tr><td>构造器注入</td><td>依赖不可变，对象创建时即完成注入</td><td>依赖较多时构造方法会很长,但可以通过Lombok改善</td><td>依赖关系稳定，推荐优先使用</td></tr></tbody></table><p><strong>推荐实践</strong>：优先使用构造器注入（特别是配合 Lombok 的<code>@RequiredArgsConstructor</code>），其次是<code>@Resource</code>注解，最后考虑<code>@Autowired</code>和 Setter 注入。构造器注入能保证对象在创建时就处于完整状态，避免了空指针异常的风险，同时也更符合依赖注入的设计理念。</p><h2 id="四、总结" tabindex="-1"><a class="header-anchor" href="#四、总结"><span>四、总结</span></a></h2><p>Spring 提供了多种 Bean 注入方式，每种方式都有其适用场景。在实际开发中，我们应根据具体需求选择合适的注入方式，遵循 &quot;构造器注入优先，字段注入谨慎使用&quot; 的原则，以提高代码的健壮性和可维护性。通过合理使用依赖注入，我们可以构建出松耦合、易测试的 Spring 应用。</p>`,43)])])}const o=n(t,[["render",l],["__file","spring.html.vue"]]),r=JSON.parse('{"path":"/backend/spring.html","title":"Spring 中 Bean 的几种注入方式详解","lang":"zn-ch","frontmatter":{},"git":{"updatedTime":1756722791000,"contributors":[{"name":"hmw","username":"hmw","email":"major@2025","commits":1,"url":"https://github.com/hmw"}],"changelog":[{"hash":"8226a6460d3cbc3fc2114dd3202afb9ade79e153","time":1756722791000,"email":"major@2025","author":"hmw","message":"spring文档上传"}]},"filePathRelative":"backend/spring.md"}');export{o as comp,r as data};
